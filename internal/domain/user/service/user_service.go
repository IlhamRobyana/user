// This generated by evm-cli, edit as necessary
package service

import (
	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"

	"context"
	"net/http"

	"github.com/IlhamRobyana/user/internal/domain/user/model"
	"github.com/IlhamRobyana/user/internal/domain/user/model/dto"
	"github.com/IlhamRobyana/user/shared/failure"
)

func (s *UserServiceImpl) CreateUser(ctx context.Context, userRequest dto.UserCreateRequest) (dto.UserResponse, error) {
	user, err := userRequest.ToModel()
	if err != nil {
		log.Error().Err(err).Msg("[CreateUser] failed convert request to model")
		return dto.UserResponse{}, err
	}
	err = s.UserRepository.CreateUser(ctx, &user)
	if err != nil {
		log.Error().Err(err).Msg("[CreateUser] failed create user")
		return dto.UserResponse{}, err
	}
	return dto.NewUserResponse(user), nil
}

func (s *UserServiceImpl) ResolveUserByID(ctx context.Context, primaryID uuid.UUID) (dto.UserResponse, error) {
	user, err := s.UserRepository.ResolveUserByID(ctx, primaryID)
	if err != nil {
		if failure.GetCode(err) != http.StatusNotFound {
			log.Error().Err(err).Msg("[ResolveUserByID] failed get user by id")
		}
		return dto.UserResponse{}, err
	}
	return dto.NewUserResponse(user), nil
}

func (s *UserServiceImpl) LoginUser(ctx context.Context, userRequest dto.UserLoginRequest) (bool, error) {
	attempt, err := s.GetLoginAttempt(ctx, userRequest.Email)
	if err != nil {
		if err.Error() != redis.Nil.Error() {
			log.Error().Err(err).Msg("[LoginUser] failed get login attempt")
			return false, err
		}
		s.SetLoginAttempt(ctx, userRequest.Email, 0, s.cfg.Internal.LoginAttemptTTL)
	}

	if attempt >= s.cfg.Internal.MaxLoginAttempt {
		err = failure.Forbidden("Max login attempts exceeded, please wait for 2 minutes for re-login")
		log.Error().Err(err).Msg("[LoginUser] failed login user")
		return false, err
	}

	var (
		isPasswordMatch bool
		user            model.User
	)
	// increase redis increment if failed to log in
	defer func() {
		if err != nil || !isPasswordMatch {
			s.SetLoginAttempt(ctx, userRequest.Email, attempt+1, s.cfg.Internal.LoginAttemptTTL)
			if attempt+1 >= s.cfg.Internal.MaxLoginAttempt {
				err = failure.Forbidden("Max login attempts exceeded, please wait for 2 minutes for re-login")
				suspendAmount, err := s.GetSuspendAmount(ctx, userRequest.Email)
				if err != nil {
					if err.Error() != redis.Nil.Error() {
						log.Error().Err(err).Msg("[LoginUser] failed get suspend amount")
						return
					}
					s.SetSuspendAmount(ctx, userRequest.Email, 0, s.cfg.Internal.SuspendAmountTTL)
				}
				s.SetSuspendAmount(ctx, userRequest.Email, suspendAmount+1, s.cfg.Internal.SuspendAmountTTL)
				if suspendAmount+1 >= s.cfg.Internal.MaxSuspendAmount {
					err = s.UserRepository.UpdateUserStatus(ctx, user.Id, model.Inactive)
					if err != nil {
						log.Error().Err(err).Msg("[LoginUser] failed update user status")
						return
					}
					return
				}
				return
			}
		}
	}()
	user, err = s.UserRepository.ResolveUserByEmail(ctx, userRequest.Email)
	if err != nil {
		if failure.GetCode(err) != http.StatusNotFound {
			log.Error().Err(err).Msg("[LoginUser] failed login user")
		}
		return false, err
	}
	isPasswordMatch, err = user.ComparePassword(userRequest.Password)
	if err != nil {
		log.Error().Err(err).Msg("[LoginUser] failed compare password")
		err = failure.Unauthorized("Invalid email or password")
		return false, err
	}

	return isPasswordMatch, nil
}

type UserService interface {
	CreateUser(ctx context.Context, userRequest dto.UserCreateRequest) (dto.UserResponse, error)
	ResolveUserByID(ctx context.Context, primaryID uuid.UUID) (dto.UserResponse, error)

	LoginUser(ctx context.Context, userRequest dto.UserLoginRequest) (bool, error)
}
