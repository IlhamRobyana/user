// This generated by evm-cli, edit as necessary
package repository

import (
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"

	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"github.com/IlhamRobyana/user/internal/domain/user/model"
	"github.com/IlhamRobyana/user/shared/failure"
)

func (repo *UserRepositoryMySQL) CreateUser(ctx context.Context, user *model.User, fieldsInsert ...UserField) (err error) {
	if len(fieldsInsert) == 0 {
		selectField := NewUserSelectFields()
		fieldsInsert = selectField.ForCreate()
	}
	primaryID := user.Id
	exists, err := repo.IsExistUserByID(ctx, primaryID)
	if err != nil {
		log.Error().Err(err).Msg("[CreateUser] failed checking user whether already exists or not")
		return err
	}
	if exists {
		err = failure.Conflict("create", "user", "already exists")
		return
	}
	fieldsStr, valueListStr, args := composeInsertFieldsAndParamsUser([]model.User{*user}, fieldsInsert...)
	commandQuery := fmt.Sprintf(userQueries.insertUser, fieldsStr, strings.Join(valueListStr, ","))
	_, err = repo.exec(ctx, commandQuery, args)
	if err != nil {
		log.Error().Err(err).Msg("[CreateUser] failed exec create user query")
		return
	}

	return
}

func (repo *UserRepositoryMySQL) ResolveUserByID(ctx context.Context, primaryID uuid.UUID, selectFields ...UserField) (user model.User, err error) {
	var (
		defaultUserSelectFields = defaultUserSelectFields()
	)
	if len(selectFields) > 0 {
		defaultUserSelectFields = composeUserSelectFields(selectFields...)
	}
	whereQry, params := composeUserCompositePrimaryKeyWhere([]uuid.UUID{primaryID})
	query := fmt.Sprintf(userQueries.selectUser+" WHERE "+whereQry, defaultUserSelectFields)
	err = repo.DB.Read.Get(&user, query, params...)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			err = failure.NotFound(fmt.Sprintf("user with id '%s' not found", fmt.Sprint(primaryID)))
			return
		}
		log.Error().Err(err).Msg("[ResolveUserByID] failed get user")
		err = failure.InternalError(err)
	}
	return
}

func (repo *UserRepositoryMySQL) ResolveUserByEmail(ctx context.Context, email string, selectFields ...UserField) (user model.User, err error) {
	var (
		defaultUserSelectFields = defaultUserSelectFields()
	)
	if len(selectFields) > 0 {
		defaultUserSelectFields = composeUserSelectFields(selectFields...)
	}
	query := fmt.Sprintf(userQueries.selectUser+" WHERE user.email = ?", defaultUserSelectFields)
	err = repo.DB.Read.Get(&user, query, email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			err = failure.NotFound(fmt.Sprintf("user with email '%s' not found", fmt.Sprint(email)))
			return
		}
		log.Error().Err(err).Msg("[ResolveUserByEmail] failed get user")
		err = failure.InternalError(err)
	}
	return
}

func (repo *UserRepositoryMySQL) IsExistUserByID(ctx context.Context, primaryID uuid.UUID) (exists bool, err error) {
	whereQuery, params := composeUserCompositePrimaryKeyWhere([]uuid.UUID{primaryID})
	query := fmt.Sprintf("%s WHERE %s ", userQueries.selectCountUser, whereQuery)
	err = repo.DB.Read.Get(&exists, query, params...)
	if err != nil {
		log.Error().Err(err).Msg("[IsExistUserByID] failed get count")
		err = failure.InternalError(err)
	}
	return
}

func (repo *UserRepositoryMySQL) UpdateUserStatus(ctx context.Context, primaryID uuid.UUID, status string) (err error) {
	query := fmt.Sprintf(userQueries.updateUser, "`status` = ? WHERE `id` = ?")
	_, err = repo.exec(ctx, query, []interface{}{status, primaryID})
	if err != nil {
		log.Error().Err(err).Msg("[UpdateUserStatus] failed update user status")
		err = failure.InternalError(err)
	}
	return
}

type UserFieldParameter struct {
	param string
	args  []interface{}
}

func NewUserFieldParameter(param string, args ...interface{}) UserFieldParameter {
	return UserFieldParameter{
		param: param,
		args:  args,
	}
}

func defaultUserSelectFields() string {
	fields := NewUserSelectFields().All()
	fieldsStr := []string{}
	for _, field := range fields {
		fieldWithBacktick := fmt.Sprintf("`%s`", string(field))
		fieldsStr = append(fieldsStr, fieldWithBacktick)
	}
	return strings.Join(fieldsStr, ",")
}

func composeUserSelectFields(selectFields ...UserField) string {
	fieldsStr := []string{}
	for _, field := range selectFields {
		fieldWithBacktick := fmt.Sprintf("`%s`", string(field))
		fieldsStr = append(fieldsStr, fieldWithBacktick)
	}
	return strings.Join(fieldsStr, ",")
}

type UserField string
type UserFieldList []UserField

type UserSelectFields struct {
}

func (ss UserSelectFields) Id() UserField {
	return UserField("id")
}

func (ss UserSelectFields) Email() UserField {
	return UserField("email")
}

func (ss UserSelectFields) Password() UserField {
	return UserField("password")
}

func (ss UserSelectFields) Fullname() UserField {
	return UserField("fullname")
}

func (ss UserSelectFields) Status() UserField {
	return UserField("status")
}

func (ss UserSelectFields) CreatedAt() UserField {
	return UserField("created_at")
}

func (ss UserSelectFields) UpdatedAt() UserField {
	return UserField("updated_at")
}

func (ss UserSelectFields) DeletedAt() UserField {
	return UserField("deleted_at")
}

func (ss UserSelectFields) CreatedBy() UserField {
	return UserField("created_by")
}

func (ss UserSelectFields) UpdatedBy() UserField {
	return UserField("updated_by")
}

func (ss UserSelectFields) DeletedBy() UserField {
	return UserField("deleted_by")
}

func (ss UserSelectFields) All() UserFieldList {
	return []UserField{
		ss.Id(),
		ss.Email(),
		ss.Password(),
		ss.Fullname(),
		ss.Status(),
		ss.CreatedAt(),
		ss.UpdatedAt(),
		ss.DeletedAt(),
		ss.CreatedBy(),
		ss.UpdatedBy(),
		ss.DeletedBy(),
	}
}

func (ss UserSelectFields) ForCreate() UserFieldList {
	return []UserField{
		ss.Id(),
		ss.Email(),
		ss.Password(),
		ss.Fullname(),
		ss.Status(),
		ss.CreatedBy(),
		ss.UpdatedBy(),
	}
}

func NewUserSelectFields() UserSelectFields {
	return UserSelectFields{}
}

type UserUpdateFieldOption struct {
	useIncrement bool
}
type UserUpdateField struct {
	userField UserField
	opt       UserUpdateFieldOption
	value     interface{}
}
type UserUpdateFieldList []UserUpdateField

func defaultUserUpdateFieldOption() UserUpdateFieldOption {
	return UserUpdateFieldOption{
		useIncrement: false,
	}
}
func SetUseIncrementUserOption(useIncrement bool) func(*UserUpdateFieldOption) {
	return func(pcufo *UserUpdateFieldOption) {
		pcufo.useIncrement = useIncrement
	}
}

func NewUserUpdateField(field UserField, val interface{}, opts ...func(*UserUpdateFieldOption)) UserUpdateField {
	defaultOpt := defaultUserUpdateFieldOption()
	for _, opt := range opts {
		opt(&defaultOpt)
	}
	return UserUpdateField{
		userField: field,
		value:     val,
		opt:       defaultOpt,
	}
}

func composeUpdateFieldsUserCommand(userUpdateFieldList UserUpdateFieldList) ([]string, []interface{}) {
	var (
		updatedFieldsQuery []string
		args               []interface{}
	)

	for _, updateField := range userUpdateFieldList {
		field := string(updateField.userField)
		valueParam := fmt.Sprintf("`%s` = ?", field)
		if updateField.opt.useIncrement {
			valueParam = fmt.Sprintf("`%s` = %s + ?", field, field)
		}
		updatedFieldsQuery = append(updatedFieldsQuery, valueParam)
		args = append(args, updateField.value)
	}

	return updatedFieldsQuery, args
}

func composeInsertFieldsAndParamsUser(userList []model.User, fieldsInsert ...UserField) (fieldStr string, valueListStr []string, args []interface{}) {
	var (
		fields []string
		values []string
	)
	for _, field := range fieldsInsert {
		fields = append(fields, fmt.Sprintf("`%s`", string(field)))
		values = append(values, "?")
	}
	fieldStr = fmt.Sprintf("(%s)", strings.Join(fields, ","))
	selectField := NewUserSelectFields()
	for _, user := range userList {
		for _, field := range fieldsInsert {
			switch field {
			case selectField.Id():
				args = append(args, user.Id)
			case selectField.Email():
				args = append(args, user.Email)
			case selectField.Password():
				args = append(args, user.Password)
			case selectField.Fullname():
				args = append(args, user.Fullname)
			case selectField.Status():
				args = append(args, user.Status)
			case selectField.CreatedAt():
				args = append(args, user.CreatedAt)
			case selectField.UpdatedAt():
				args = append(args, user.UpdatedAt)
			case selectField.DeletedAt():
				args = append(args, user.DeletedAt)
			case selectField.CreatedBy():
				args = append(args, user.CreatedBy)
			case selectField.UpdatedBy():
				args = append(args, user.UpdatedBy)
			case selectField.DeletedBy():
				args = append(args, user.DeletedBy)

			}
		}
		valueListStr = append(valueListStr, fmt.Sprintf("(%s)", strings.Join(values, ",")))
	}
	return
}

func composeUserCompositePrimaryKeyWhere(primaryIDs []uuid.UUID) (whereQry string, params []interface{}) {
	var primaryKeyQry []string
	for _, primaryID := range primaryIDs {
		var arrWhereQry []string
		id := "`user`.`id` = ?"
		params = append(params, primaryID)
		arrWhereQry = append(arrWhereQry, id)

		qry := fmt.Sprintf("(%s)", strings.Join(arrWhereQry, " AND "))
		primaryKeyQry = append(primaryKeyQry, qry)
	}

	return strings.Join(primaryKeyQry, " OR "), params
}

var (
	userQueries = struct {
		selectUser      string
		selectCountUser string
		deleteUser      string
		updateUser      string
		insertUser      string
	}{
		selectUser:      "SELECT %s FROM `user`",
		selectCountUser: "SELECT COUNT(`id`) FROM `user`",
		deleteUser:      "DELETE FROM `user`",
		updateUser:      "UPDATE `user` SET %s ",
		insertUser:      "INSERT INTO `user` %s VALUES %s",
	}
)

type UserRepository interface {
	ResolveUserByID(ctx context.Context, userID uuid.UUID, selectFields ...UserField) (model.User, error)
	CreateUser(ctx context.Context, user *model.User, fieldsInsert ...UserField) error
	IsExistUserByID(ctx context.Context, userID uuid.UUID) (bool, error)
	ResolveUserByEmail(ctx context.Context, email string, selectFields ...UserField) (model.User, error)
	UpdateUserStatus(ctx context.Context, primaryID uuid.UUID, status string) (err error)
}
